# TODO: Refactor so token gets pulled only when it's absent
- name: Get a token if needed
  ansible.builtin.uri:
    url: "https://{{ portainer_ip }}:{{ portainer_port }}/api/auth"
    method: POST
    return_content: true
    body_format: json
    status_code: 200
    validate_certs: false
    body:
      Username: "{{ portainer_username }}"
      Password: "{{ portainer_password }}"
  register: auth_token

- name: Check if stack exists
  ansible.builtin.uri:
    url: "https://{{ portainer_ip }}:{{ portainer_port }}/api/stacks"
    method: GET
    validate_certs: false
    return_content: true
    headers:
      Authorization: Bearer {{ (auth_token.content | from_json).jwt }}
  register: content

# Systemd resolver needs to be reconfgiured, so AgGuard container can work
- name: Check if resolv.conf has been modified yet
  ansible.builtin.lineinfile:
    path: /etc/resolv.conf
    state: present
    line: "nameserver 127.0.0.1"
  check_mode: true
  register: check_resolvconf
  when: "'adguardhome' in item.Container"
  loop: "{{ portainer_stack_list }}"
  notify:
    - Create resolved.conf.d directory
    - Template a systemd configuration
    - Backup original resolf.conf
    - Delete original resolv.conf
    - Link a new resolv.conf instead
    - Restart DNSStubListener
    - Make sure DNSStubListener is running

- name: Force Service restarts
# Othwesie AdGuard won't deploy with an error
  ansible.builtin.meta: flush_handlers

- name: Deploy all absent stacks
  ansible.builtin.uri:
    url: "https://{{ portainer_ip }}:{{ portainer_port }}/api/stacks?type=2&method=string&endpointId={{ portainer_endpoint_id }}"
    method: POST
    body_format: json
    validate_certs: false
# Paperless-ngx takes an eternity to deploy
    timeout: '500'
    headers:
      Authorization: Bearer {{ (auth_token.content | from_json).jwt }}
    body:
      name: "{{ item.Container }}"
      stackFileContent: "{{ lookup('template', 'roles/portainer_setup/templates/compose/{{ item.Container }}.j2') }}"
  loop: "{{ portainer_stack_list }}"
  when: "item.Container not in content.json | json_query('[*].Name')"
