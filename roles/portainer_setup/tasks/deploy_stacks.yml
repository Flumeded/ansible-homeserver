# TODO: Refactor so token gets pulled only when it's absent
- name: Get a token if needed
  ansible.builtin.uri:
    url: "https://{{ portainer_ip }}:{{ portainer_port }}/api/auth"
    method: POST
    return_content: true
    body_format: json
    status_code: 200
    validate_certs: false
    body:
      Username: "{{ portainer_username }}"
      Password: "{{ portainer_password }}"
  register: auth_token

- name: Check if stack exists
  ansible.builtin.uri:
    url: "https://{{ portainer_ip }}:{{ portainer_port }}/api/stacks"
    method: GET
    validate_certs: false
    return_content: true
    headers:
      Authorization: Bearer {{ (auth_token.content | from_json).jwt }}
  register: content

# Systemd resolver needs to be reconfgiured, so AgGuard container can work
- name: Check if resolv.conf has been modified yet
  ansible.builtin.lineinfile:
    path: /etc/resolv.conf
    state: present
    line: "nameserver 127.0.0.1"
  check_mode: true
  register: check_resolvconf
  when: "'adguardhome' in item.Container"
  loop: "{{ portainer_stack_list }}"
  notify:
    - Create resolved.conf.d directory
    - Template a systemd configuration
    - Backup original resolf.conf
    - Delete original resolv.conf
    - Link a new resolv.conf instead
    - Restart DNSStubListener
    - Make sure DNSStubListener is running

- name: Force Service restarts
# Othwesie AdGuard won't deploy with an error
  ansible.builtin.meta: flush_handlers

- name: Find and read Docker Compose template files
  # This task generate a list of all volumes defined in my compose files, so they can be later added to the Offen container for backups.
  ansible.builtin.set_fact:
    compose_volumes: "{{ compose_volumes + ((lookup('template', item) | from_yaml).volumes | default({})).keys() | list | default([]) }}"
    # It sets a variable called 'compose_volumes' by appending to its existing value.
    # The appended value is obtained from the following steps:

    # 1. 'lookup('template', item)' reads and processes a template file specified by 'item'.
    #    It converts the template content into YAML format, since my Compose files are Jinja Templates

    # 2. 'from_yaml' converts the YAML content into a structured data format.

    # 3. '.volumes' extracts a dictionary from the structured data, if it exists.
    #    This assumes that the Docker Compose template contains a 'volumes' section.

    # 4. 'default({})' ensures that if there is no 'volumes' section in the template,
    #    it defaults to an empty dictionary to prevent errors.

    # 5. '.keys()' extracts the keys (volume names) from the 'volumes' dictionary.

    # 6. '| list' converts the keys into a list if they are not already in list format.

    # 7. 'default([])' ensures that if there are no keys (volumes), it defaults to an empty list.

  loop: "{{ query('fileglob', 'roles/portainer_setup/templates/compose/*.j2') }}"
  # The 'loop' iterates over a list of all Compose templates.

- name: Deploy all absent stacks
  ansible.builtin.uri:
    url: "https://{{ portainer_ip }}:{{ portainer_port }}/api/stacks?type=2&method=string&endpointId={{ portainer_endpoint_id }}"
    method: POST
    body_format: json
    validate_certs: false
# Paperless-ngx takes an eternity to deploy
    timeout: '500'
    headers:
      Authorization: Bearer {{ (auth_token.content | from_json).jwt }}
    body:
      name: "{{ item.Container }}"
      stackFileContent: "{{ lookup('template', 'roles/portainer_setup/templates/compose/{{ item.Container }}.j2') }}"
  loop: "{{ portainer_stack_list }}"
  when: "item.Container not in content.json | json_query('[*].Name')"
